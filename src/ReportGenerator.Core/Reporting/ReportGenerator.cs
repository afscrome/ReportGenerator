using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Palmmedia.ReportGenerator.Core.Common;
using Palmmedia.ReportGenerator.Core.Logging;
using Palmmedia.ReportGenerator.Core.Parser;
using Palmmedia.ReportGenerator.Core.Parser.Analysis;
using Palmmedia.ReportGenerator.Core.Parser.FileReading;
using Palmmedia.ReportGenerator.Core.Properties;

namespace Palmmedia.ReportGenerator.Core.Reporting
{
    /// <summary>
    /// Converts a coverage report generated by OpenCoverand other tools into a readable report.
    /// </summary>
    internal class ReportGenerator
    {
        // TODO: Make this configurable
        private const int MaxConcurrency = 8;

        /// <summary>
        /// The Logger.
        /// </summary>
        private static readonly ILogger Logger = LoggerFactory.GetLogger(typeof(ReportGenerator));

        /// <summary>
        /// The file reader to use.
        /// </summary>
        private readonly IFileReader fileReader;

        /// <summary>
        /// The parser to use.
        /// </summary>
        private readonly ParserResult parserResult;

        /// <summary>
        /// The renderers.
        /// </summary>
        private readonly List<IReportBuilder> renderers;

        /// <summary>
        /// Initializes a new instance of the <see cref="ReportGenerator" /> class.
        /// </summary>
        /// <param name="fileReader">The file reader.</param>
        /// <param name="parserResult">The parser result to use.</param>
        /// <param name="renderers">The renderers.</param>
        internal ReportGenerator(IFileReader fileReader, ParserResult parserResult, IEnumerable<IReportBuilder> renderers)
        {
            this.fileReader = fileReader ?? throw new ArgumentNullException(nameof(fileReader));
            this.parserResult = parserResult ?? throw new ArgumentNullException(nameof(parserResult));
            this.renderers = renderers?.ToList() ?? throw new ArgumentNullException(nameof(renderers));
        }

        /// <summary>
        /// Starts the generation of the report.
        /// </summary>
        /// <param name="addHistoricCoverage">if set to <c>true</c> historic coverage information is added to classes.</param>
        /// <param name="overallHistoricCoverages">All historic coverage elements.</param>
        /// <param name="executionTime">The execution time.</param>
        /// <param name="tag">The custom tag (e.g. build number).</param>
        internal void CreateReport(bool addHistoricCoverage, List<HistoricCoverage> overallHistoricCoverages, DateTime executionTime, string tag)
        {
            // TODO: Can we change overallHistoricCoverages to a ConcurrentBag to avoid this?
            object overallHistoricCoveragesLock = new object();

            // TODO: This probably belongs in the ReportGenerator Console and/or Global Tool
            //       AND can probably be a bit smarter.
            //
            // If there aren't enough threads in the thread pool, the Parallelism here can deadlock until the pool grows large enough
            // With all avaialble threads being used in class analysis, but with ConcurrentReportBuilder threads having
            // to wait for the thread pool to grow.  By default, .Net core adds 2 threads every 0.5 secs
            // App will become responsive within a few seconds, but given that report generator can complete in tens of seconds,
            // these stalls become significant
            ThreadPool.SetMinThreads(200, 200);

            var allClasses = this.parserResult.Assemblies.SelectMany(a => a.Classes);
            var classAnalysis = Partitioner.Create(allClasses, EnumerablePartitionerOptions.NoBuffering)
                .AsParallel()
                .AsOrdered()
                .WithDegreeOfParallelism(MaxConcurrency)
                .Select(AnalyseClass)
                .AsSequential();

            int numberOfClasses = this.parserResult.Assemblies.SafeSum(a => a.Classes.Count());

            Logger.DebugFormat(Resources.AnalyzingClasses, numberOfClasses);

            int counter = 0;
            var concurrentRenderers = this.renderers.OfType<IParallelisableReportBuilder>().ToList();
            var sequentialRenderers = this.renderers.Except(concurrentRenderers).ToList();

            var concurrentRenderQueue = new BlockingCollection<(IReportBuilder renderer, Class @class, List<FileAnalysis> analysis)>(MaxConcurrency);
            Task concurrentRendererTask = Task.CompletedTask;

            if (concurrentRenderers.Any())
            {
                concurrentRendererTask = Task.Factory.StartNew(() =>
                {
                    Partitioner.Create(concurrentRenderQueue.GetConsumingEnumerable(), EnumerablePartitionerOptions.NoBuffering)
                        .AsParallel()
                        .WithDegreeOfParallelism(MaxConcurrency)
                        .ForAll(x => RenderReport(x.renderer, x.@class, x.analysis));
                });
            }

            foreach (var (@class, analysis) in classAnalysis)
            {
                counter++;
                Logger.DebugFormat(
                    Resources.CreatingReport,
                    counter,
                    numberOfClasses,
                    @class.Assembly.ShortName,
                    @class.Name);

                foreach (var renderer in concurrentRenderers)
                {
                    concurrentRenderQueue.Add((renderer, @class, analysis));
                }

                sequentialRenderers
                    .AsParallel()
                    .WithMergeOptions(ParallelMergeOptions.NotBuffered)
                    .ForAll(x => RenderReport(x, @class, analysis));
            }

            concurrentRenderQueue.CompleteAdding();
            concurrentRendererTask.Wait();

            Logger.Debug(Resources.CreatingSummary);
            SummaryResult summaryResult = new SummaryResult(this.parserResult);

            foreach (var renderer in this.renderers)
            {
                try
                {
                    renderer.CreateSummaryReport(summaryResult);
                }
                catch (Exception ex)
                {
                    Logger.ErrorFormat(
                        Resources.ErrorDuringRenderingSummaryReport,
                        renderer.ReportType,
                        ex.GetExceptionMessageForDisplay());

                    if (Logger.VerbosityLevel == VerbosityLevel.Verbose)
                    {
                        Logger.Error(ex.StackTrace);
                    }
                }
            }

            (Class @class, List<FileAnalysis> analysis) AnalyseClass(Class @class)
            {
                var fileAnalyses = @class.Files.Select(f => f.AnalyzeFile(this.fileReader)).ToList();

                if (addHistoricCoverage)
                {
                    var historicCoverage = new HistoricCoverage(@class, executionTime, tag);
                    @class.AddHistoricCoverage(historicCoverage);

                    lock (overallHistoricCoveragesLock)
                    {
                        overallHistoricCoverages.Add(historicCoverage);
                    }
                }

                return (@class, fileAnalyses);
            }
        }

        private static void RenderReport(IReportBuilder renderer, Class @class, List<FileAnalysis> analysis)
        {
            try
            {
                renderer.CreateClassReport(@class, analysis);
            }
            catch (Exception ex)
            {
                Logger.ErrorFormat(
                    Resources.ErrorDuringRenderingClassReport,
                    @class.Name,
                    renderer.ReportType,
                    ex.GetExceptionMessageForDisplay());
            }
        }
    }
}